<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>/Users/jacob/Documents/Projects/130-project/hagglehaul/hagglehaul.Server/Controllers/DriverController.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Security.Claims;
using hagglehaul.Server.EmailViews;
using hagglehaul.Server.Models;
using hagglehaul.Server.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Http.HttpResults;
using Microsoft.AspNetCore.Mvc;
using Swashbuckle.AspNetCore.Annotations;

namespace hagglehaul.Server.Controllers
{
    /// &lt;summary&gt;
    /// Controller for driver-related operations.
    /// &lt;/summary&gt;
    [Route(&quot;api/[controller]&quot;)]
    [ApiController]
    public class DriverController : ControllerBase
    {
        private readonly IDriverProfileService _driverProfileService;
        private readonly IRiderProfileService _riderProfileService;
        private readonly IUserCoreService _userCoreService;
        private readonly ITripService _tripService;
        private readonly IBidService _bidService;
        private readonly IGeographicRouteService _geographicRouteService;
        private readonly IEmailNotificationService _emailNotificationService;

        public DriverController(
            IDriverProfileService driverProfileService,
            IRiderProfileService riderProfileService,
            IUserCoreService userCoreService,
            ITripService tripService,
            IBidService bidService,
            IGeographicRouteService geographicRouteService,
            IEmailNotificationService emailNotificationService
        )
        {
            _driverProfileService = driverProfileService;
            _riderProfileService = riderProfileService;
            _userCoreService = userCoreService;
            _tripService = tripService;
            _bidService = bidService;
            _geographicRouteService = geographicRouteService;
            _emailNotificationService = emailNotificationService;
        }

        /// &lt;summary&gt;
        /// Gets the necessary info for a driver dashboard. Shows confirmed trips, trips in bidding, and past trips.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// &lt;see cref=&quot;OkObjectResult&quot;/&gt; if the dashboard is successfully returned,
        /// &lt;see cref=&quot;BadRequestObjectResult&quot;/&gt; if the user is invalid or not authenticated,
        /// &lt;see cref=&quot;UnauthorizedResult&quot;/&gt; if the user is not a driver
        /// &lt;/returns&gt;
        [Authorize]
        [HttpGet]
        [Route(&quot;dashboard&quot;)]
        [ProducesResponseType(typeof(DriverDashboard), StatusCodes.Status200OK)]
        [SwaggerOperation(Summary = &quot;Gets the necessary info for a driver dashboard. Shows confirmed trips, trips in bidding, and past trips.&quot;)]
        [SwaggerResponse(StatusCodes.Status200OK, &quot;Succesfully returned the dashboard.&quot;)]
        [SwaggerResponse(StatusCodes.Status400BadRequest, &quot;Invalid User or Authentication&quot;)]
        [SwaggerResponse(StatusCodes.Status401Unauthorized, &quot;The user is not a driver.&quot;)]
        public async Task&lt;IActionResult&gt; GetDashboard()
        {
            ClaimsPrincipal currentUser = this.User;
            if (currentUser == null)
            {
                return BadRequest(new { Error = &quot;Invalid User/Auth&quot; });
            }
            var role = currentUser.FindFirstValue(ClaimTypes.Role);
            if (role != &quot;driver&quot;)
            {
                return Unauthorized();
            }

            var email = currentUser.FindFirstValue(ClaimTypes.Name); //name is the email
            UserCore userCore = await _userCoreService.GetAsync(email);
            DriverDashboard driverDashboard = new DriverDashboard();
            List&lt;ConfirmedDriverTrip&gt; confirmedTrips = new List&lt;ConfirmedDriverTrip&gt;();
            List&lt;UnconfirmedDriverTrip&gt; unconfirmedTrips = new List&lt;UnconfirmedDriverTrip&gt;();
            List&lt;ArchivedDriverTrip&gt; archivedTrips = new List&lt;ArchivedDriverTrip&gt;();
            List&lt;Bid&gt; allBids = await _bidService.GetDriverBidsAsync(email);
            foreach (Bid bid in allBids ?? Enumerable.Empty&lt;Bid&gt;())
            {
                //if trip date is in past, trip is archived
                //if trip date is in future, email null, trip is in bidding
                //if trip date is in future, email !null, trip is confirmed
                Trip trip = await _tripService.GetTripByIdAsync(bid.TripId);
                TimeSpan day = new TimeSpan(24, 0, 0);
                DateTime pastPlusOne = trip.StartTime.Add(day).ToLocalTime();
                //archived Trips
                GeographicRoute geographicRoute = await _geographicRouteService.GetGeographicRoute(trip.PickupLong, trip.PickupLat, trip.DestinationLong, trip.DestinationLat);
                uint cost = bid.CentsAmount;
                bool hasDriver = !String.IsNullOrEmpty(trip.DriverEmail);
                if (DateTime.Now &gt; pastPlusOne || (hasDriver &amp;&amp; trip.DriverEmail != email))
                {
                    ArchivedDriverTrip archive = new ArchivedDriverTrip();
                    archive.TripId = trip.Id;
                    archive.TripName = trip.Name;
                    archive.StartTime = trip.StartTime;
                    archive.Thumbnail = geographicRoute.Image;
                    archive.GeoJson = geographicRoute.GeoJson;
                    archive.Distance = geographicRoute.Distance;
                    archive.Duration = geographicRoute.Duration;
                    archive.Cost = cost;
                    RiderProfile rider = await _riderProfileService.GetAsync(trip.RiderEmail);
                    UserCore riderCore = await _userCoreService.GetAsync(trip.RiderEmail);
                    archive.RiderName = riderCore.Name;
                    archive.RiderNumRating = rider.NumRatings;
                    archive.RiderRating = rider.Rating;
                    archive.PickupAddress = trip.PickupAddress;
                    archive.DestinationAddress = trip.DestinationAddress;
                    archivedTrips.Add(archive);
                }
                else if (hasDriver &amp;&amp; trip.DriverEmail == email)
                {
                    //confirmed trip
                    ConfirmedDriverTrip confirmedTrip = new ConfirmedDriverTrip();
                    RiderProfile rider = await _riderProfileService.GetAsync(trip.RiderEmail);
                    UserCore riderCore = await _userCoreService.GetAsync(trip.RiderEmail);
                    confirmedTrip.TripID = trip.Id;
                    confirmedTrip.TripName = trip.Name;
                    confirmedTrip.Thumbnail = geographicRoute.Image;
                    confirmedTrip.GeoJson = geographicRoute.GeoJson;
                    confirmedTrip.StartTime = trip.StartTime;
                    confirmedTrip.Distance = geographicRoute.Distance;
                    confirmedTrip.Duration = geographicRoute.Duration;
                    confirmedTrip.Cost = cost;
                    confirmedTrip.RiderName = riderCore.Name;
                    confirmedTrip.RiderRating = rider.Rating;
                    confirmedTrip.RiderNumRating = rider.NumRatings;
                    confirmedTrip.ShowRatingPrompt = !trip.RiderHasBeenRated &amp;&amp; DateTime.Now &gt; trip.StartTime.ToLocalTime() &amp;&amp; DateTime.Now &lt;= pastPlusOne;
                    confirmedTrip.RiderEmail = riderCore.Email;
                    confirmedTrip.RiderPhone = riderCore.Phone;
                    confirmedTrip.PickupAddress = trip.PickupAddress;
                    confirmedTrip.DestinationAddress = trip.DestinationAddress;
                    confirmedTrips.Add(confirmedTrip);
                }
                else
                {
                    //unconfirmed trip
                    UnconfirmedDriverTrip unconfirmedTrip = new UnconfirmedDriverTrip();
                    UserCore riderCore = await _userCoreService.GetAsync(trip.RiderEmail);
                    RiderProfile rider = await _riderProfileService.GetAsync(trip.RiderEmail);
                    unconfirmedTrip.TripID = trip.Id;
                    unconfirmedTrip.TripName = trip.Name;
                    unconfirmedTrip.Thumbnail = geographicRoute.Image;
                    unconfirmedTrip.GeoJson = geographicRoute.GeoJson;
                    unconfirmedTrip.StartTime = trip.StartTime;
                    unconfirmedTrip.Distance = geographicRoute.Distance;
                    unconfirmedTrip.Duration = geographicRoute.Duration;
                    unconfirmedTrip.RiderName = riderCore.Name;
                    unconfirmedTrip.RiderRating = rider.Rating;
                    unconfirmedTrip.RiderNumRating = rider.NumRatings;
                    List&lt;Bid&gt; tripBids = await _bidService.GetTripBidsAsync(trip.Id);
                    unconfirmedTrip.Bids = new List&lt;BidUserView&gt;();
                    foreach (Bid tripBid in tripBids ?? Enumerable.Empty&lt;Bid&gt;())
                    {
                        BidUserView bidUserView = new BidUserView();
                        UserCore driverCore = await _userCoreService.GetAsync(tripBid.DriverEmail);
                        DriverProfile driver = await _driverProfileService.GetAsync(tripBid.DriverEmail);
                        bidUserView.BidId = tripBid.Id;
                        bidUserView.DriverName = driverCore.Name;
                        bidUserView.DriverRating = driver.Rating;
                        bidUserView.DriverNumRating = driver.NumRatings;
                        bidUserView.Cost = tripBid.CentsAmount;
                        if (tripBid.DriverEmail == email)
                        {
                            bidUserView.YourBid = true;
                            unconfirmedTrip.Bids.Insert(0, bidUserView);
                        }
                        else
                        {
                            bidUserView.YourBid = false;
                            unconfirmedTrip.Bids.Add(bidUserView);
                        }
                    }
                    unconfirmedTrip.PickupAddress = trip.PickupAddress;
                    unconfirmedTrip.DestinationAddress = trip.DestinationAddress;
                    unconfirmedTrips.Add(unconfirmedTrip);
                }
            }
            driverDashboard.ConfirmedTrips = confirmedTrips;
            driverDashboard.TripsInBidding = unconfirmedTrips;
            driverDashboard.ArchivedTrips = archivedTrips;
            return Ok(driverDashboard);
        }

        /// &lt;summary&gt;
        /// Get the basic info of the current driver.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// &lt;see cref=&quot;OkObjectResult&quot;/&gt; if the driver&#39;s basic info is successfully returned,
        /// &lt;see cref=&quot;BadRequestObjectResult&quot;/&gt; if the user is invalid or not authenticated,
        /// &lt;see cref=&quot;UnauthorizedResult&quot;/&gt; if the user is not a driver
        /// &lt;/returns&gt;
        [Authorize]
        [HttpGet]
        [Route(&quot;about&quot;)]
        [ProducesResponseType(typeof(DriverBasicInfo), StatusCodes.Status200OK)]
        [SwaggerOperation(Summary = &quot;Get the basic info of the current driver.&quot;)]
        [SwaggerResponse(StatusCodes.Status200OK, &quot;Got the driver&#39;s basic info.&quot;)]
        [SwaggerResponse(StatusCodes.Status400BadRequest, &quot;Invalid user/auth&quot;)]
        [SwaggerResponse(StatusCodes.Status401Unauthorized, &quot;The user is not a driver.&quot;)]
        public async Task&lt;IActionResult&gt; Get()
        {
            ClaimsPrincipal currentUser = this.User;
            if (currentUser == null)
            {
                return BadRequest(new { Error = &quot;Invalid User/Auth&quot; });
            }
            var role = currentUser.FindFirstValue(ClaimTypes.Role);
            if (role != &quot;driver&quot;)
            {
                return Unauthorized();
            }
            var email = currentUser.FindFirstValue(ClaimTypes.Name); //name is the email
            UserCore userCore = await _userCoreService.GetAsync(email);
            DriverProfile driverProfile = await _driverProfileService.GetAsync(email);
            DriverBasicInfo driverBasicInfo = new DriverBasicInfo();
            driverBasicInfo.Name = userCore.Name;
            driverBasicInfo.Email = email;
            driverBasicInfo.Phone = userCore.Phone;
            driverBasicInfo.CarDescription = driverProfile.CarDescription;
            return Ok(driverBasicInfo);
        }

        /// &lt;summary&gt;
        /// Modify account details, including password.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;driverUpdate&quot;&gt;The update form.&lt;/param&gt;
        /// &lt;returns&gt;
        /// &lt;see cref=&quot;OkResult&quot;/&gt; if the account details are successfully updated,
        /// &lt;see cref=&quot;BadRequestObjectResult&quot;/&gt; if the user is invalid or not authenticated,
        /// &lt;see cref=&quot;UnauthorizedResult&quot;/&gt; if the user is not a driver
        /// &lt;/returns&gt;
        [Authorize]
        [HttpPost]
        [Route(&quot;modifyAcc&quot;)]
        [SwaggerOperation(Summary = &quot;Modify account details, including password.&quot;)]
        [SwaggerResponse(StatusCodes.Status200OK, &quot;Successfully updated the account details.&quot;)]
        [SwaggerResponse(StatusCodes.Status400BadRequest, &quot;Invalid user/auth or error with updating password.&quot;)]
        [SwaggerResponse(StatusCodes.Status401Unauthorized, &quot;The user is not a driver.&quot;)]
        public async Task&lt;IActionResult&gt; ModifyAccountDetails([FromBody] DriverUpdate driverUpdate)
        {
            ClaimsPrincipal currentUser = this.User;

            if (currentUser == null)
            {
                return BadRequest(new { Error = &quot;Invalid User/Auth&quot; });
            }
            var role = currentUser.FindFirstValue(ClaimTypes.Role);
            if (role != &quot;driver&quot;)
            {
                return Unauthorized();
            }
            bool changingPassword = !String.IsNullOrEmpty(driverUpdate.NewPassword);
            if (String.IsNullOrEmpty(driverUpdate.CurrentPassword) &amp;&amp; changingPassword)
            {
                return BadRequest(new { Error = &quot;Can&#39;t make a new password&quot; });
            }

            //check role for error
            var email = currentUser.FindFirstValue(ClaimTypes.Name); //name is the email

            UserCore userCore = await _userCoreService.GetAsync(email);
            DriverProfile driverProfile = await _driverProfileService.GetAsync(email);
            if (changingPassword)
            {

                if (!_userCoreService.ComparePasswordToHash(driverUpdate.CurrentPassword, userCore.PasswordHash, userCore.Salt))
                {
                    return BadRequest(new { Error = &quot;Current Password is invalid&quot; });
                }

            }

            if (changingPassword)
            {
                _userCoreService.CreatePasswordHash(driverUpdate.NewPassword, out var newHash, out var newSalt);
                userCore.PasswordHash = newHash;
                userCore.Salt = newSalt;
            }
            if (!String.IsNullOrEmpty(driverUpdate.Name))
            {
                userCore.Name = driverUpdate.Name;
            }
            if (!String.IsNullOrEmpty(driverUpdate.Phone))
            {
                userCore.Phone = driverUpdate.Phone;
            }
            if (!String.IsNullOrEmpty(driverUpdate.CarDescription))
            {
                driverProfile.CarDescription = driverUpdate.CarDescription;
            }
            await _userCoreService.UpdateAsync(email, userCore);
            await _driverProfileService.UpdateAsync(email, driverProfile);
            return Ok();
        }

        /// &lt;summary&gt;
        /// Create or update a bid for a trip.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;request&quot;&gt;The bidding form.&lt;/param&gt;
        /// &lt;returns&gt;
        /// &lt;see cref=&quot;OkResult&quot;/&gt; if the bid was successfully created or updated,
        /// &lt;see cref=&quot;BadRequestObjectResult&quot;/&gt; if the tripId is invalid or the trip is either confirmed or in the past,
        /// &lt;see cref=&quot;UnauthorizedResult&quot;/&gt; if the user is not a driver
        /// &lt;/returns&gt;
        [HttpPost]
        [HttpPatch]
        [Route(&quot;bid&quot;)]
        [Authorize]
        [SwaggerOperation(Summary = &quot;Create or update a bid for a trip.&quot;)]
        [SwaggerResponse(StatusCodes.Status200OK, &quot;The bid was successfully created or updated.&quot;)]
        [SwaggerResponse(StatusCodes.Status400BadRequest, &quot;The tripId is invalid or the trip is either confirmed or in the past.&quot;)]
        [SwaggerResponse(StatusCodes.Status401Unauthorized, &quot;The user is not a driver.&quot;)]
        public async Task&lt;IActionResult&gt; CreateOrUpdateBid([FromBody] CreateOrUpdateBid request)
        {
            ClaimsPrincipal currentUser = this.User;
            var username = currentUser.FindFirstValue(ClaimTypes.Name);
            var role = currentUser.FindFirstValue(ClaimTypes.Role);
            if (role != &quot;driver&quot;)
            {
                return Unauthorized();
            }

            Trip trip = await _tripService.GetTripByIdAsync(request.TripId);
            if (String.IsNullOrEmpty(request.TripId) || trip == null)
            {
                return BadRequest(new { Error = &quot;Invalid tripId&quot; });
            }

            if (!String.IsNullOrEmpty(trip.DriverEmail) || trip.StartTime.ToLocalTime() &lt; DateTime.Now)
            {
                return BadRequest(new { Error = &quot;The trip is either confirmed or in the past&quot; });
            }

            if (request.CentsAmount &lt;= 0)
            {
                return BadRequest(new { Error = &quot;Invalid centsAmount for trip&quot; });
            }

            Bid existingBid = (await _bidService.GetDriverBidsAsync(username)).FirstOrDefault(bid =&gt; bid.TripId == request.TripId);
            if (existingBid != null)
            {
                // Create bid
                existingBid.CentsAmount = request.CentsAmount;
                await _bidService.UpdateAsync(existingBid.Id, existingBid);
            }
            else
            {
                // Update bid
                await _bidService.CreateAsync(new Bid
                {
                    DriverEmail = username,
                    TripId = request.TripId,
                    CentsAmount = request.CentsAmount
                });
            }

            UserCore riderUser = await _userCoreService.GetAsync(trip.RiderEmail);
            UserCore driverUser = await _userCoreService.GetAsync(username);
            DriverProfile driverProfile = await _driverProfileService.GetAsync(username);
            _ = _emailNotificationService.SendEmailNotification(
                EmailNotificationType.NewBid,
                trip.RiderEmail,
                new NewBidEmail
                {
                    RiderName = riderUser.Name,
                    TripName = trip.Name,
                    DriverName = driverUser.Name,
                    DriverRating = driverProfile.Rating,
                    Price = (decimal)(request.CentsAmount / 100.0),
                    StartTime = trip.StartTime,
                    PickupAddress = trip.PickupAddress,
                    DestinationAddress = trip.DestinationAddress,
                    RiderEmail = trip.RiderEmail,
                }
            );

            return Ok();
        }

        /// &lt;summary&gt;
        /// Delete a bid for a trip.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;tripId&quot;&gt;The ID of the trip to delete the user&#39;s bid from&lt;/param&gt;
        /// &lt;returns&gt;
        /// &lt;see cref=&quot;OkResult&quot;/&gt; if the bid was successfully deleted,
        /// &lt;see cref=&quot;BadRequestObjectResult&quot;/&gt; if the tripId is invalid or the trip is either confirmed or in the past,
        /// &lt;see cref=&quot;UnauthorizedResult&quot;/&gt; if the user is not a driver
        /// &lt;/returns&gt;
        [HttpDelete]
        [Route(&quot;bid&quot;)]
        [Authorize]
        [SwaggerOperation(Summary = &quot;Delete a bid for a trip.&quot;)]
        [SwaggerResponse(StatusCodes.Status200OK, &quot;The bid was successfully deleted.&quot;)]
        [SwaggerResponse(StatusCodes.Status400BadRequest, &quot;The tripId is invalid or the trip is either confirmed or in the past.&quot;)]
        [SwaggerResponse(StatusCodes.Status401Unauthorized, &quot;The user is not a driver.&quot;)]
        public async Task&lt;IActionResult&gt; DeleteBid([FromQuery] string tripId)
        {
            ClaimsPrincipal currentUser = this.User;
            var username = currentUser.FindFirstValue(ClaimTypes.Name);
            var role = currentUser.FindFirstValue(ClaimTypes.Role);
            if (role != &quot;driver&quot;)
            {
                return Unauthorized();
            }

            Trip trip = await _tripService.GetTripByIdAsync(tripId);
            if (String.IsNullOrEmpty(tripId) || trip == null)
            {
                return BadRequest(new { Error = &quot;Invalid tripId&quot; });
            }

            if (!String.IsNullOrEmpty(trip.DriverEmail) || trip.StartTime.ToLocalTime() &lt; DateTime.Now)
            {
                return BadRequest(new { Error = &quot;The trip is either confirmed or in the past&quot; });
            }

            Bid existingBid = (await _bidService.GetDriverBidsAsync(username)).FirstOrDefault(bid =&gt; bid.TripId == tripId);
            if (existingBid != null)
            {
                await _bidService.DeleteAsync(existingBid.Id);
            }
            else
            {
                return BadRequest(new { Error = &quot;No bid found for this trip&quot; });
            }

            return Ok();
        }

        private async Task&lt;Dictionary&lt;string, GeographicRoute&gt;&gt; GetTripIdToRouteMap(
            IEnumerable&lt;Trip&gt; trips,
            Dictionary&lt;string, GeographicRoute&gt;? cache
        )
        {
            if (cache != null)
                return cache;
            var tripRoutes = new Dictionary&lt;string, GeographicRoute&gt;();
            await Task.WhenAll(trips.Select(async trip =&gt;
            {
                var route = await _geographicRouteService.GetGeographicRoute(
                    trip.PickupLong,
                    trip.PickupLat,
                    trip.DestinationLong,
                    trip.DestinationLat
                );
                tripRoutes.Add(trip.Id, route);
            }));
            return tripRoutes;
        }

        private async Task&lt;Dictionary&lt;string, List&lt;Bid&gt;&gt;&gt; GetTripIdToBidMap(
            IEnumerable&lt;Trip&gt; trips,
            Dictionary&lt;string, List&lt;Bid&gt;&gt;? cache
        )
        {
            if (cache != null)
                return cache;
            var tripBids = new Dictionary&lt;string, List&lt;Bid&gt;&gt;();
            await Task.WhenAll(trips.Select(async trip =&gt;
            {
                var bids = await _bidService.GetTripBidsAsync(trip.Id);
                tripBids.Add(trip.Id, bids);
            }));
            return tripBids;
        }

        private async Task&lt;Dictionary&lt;string, uint?&gt;&gt; GetTripIdToMinBidAmountMap(
            IEnumerable&lt;Trip&gt; trips,
            Dictionary&lt;string, uint?&gt;? cache,
            Dictionary&lt;string, List&lt;Bid&gt;&gt;? bidCache
        )
        {
            if (cache != null)
                return cache;
            bidCache = await GetTripIdToBidMap(trips, bidCache);
            var tripMinBidAmounts = new Dictionary&lt;string, uint?&gt;();
            foreach (var trip in trips)
            {
                tripMinBidAmounts.Add(
                    trip.Id,
                    bidCache[trip.Id].Select(bid =&gt; bid.CentsAmount).DefaultIfEmpty().Min()
                );
            }
            return tripMinBidAmounts;
        }

        private async Task&lt;Dictionary&lt;string, DriverProfile&gt;&gt; GetBidIdToDriverMap(
            IEnumerable&lt;Bid&gt; bids,
            Dictionary&lt;string, DriverProfile&gt;? cache
        )
        {
            if (cache != null)
                return cache;
            var bidDrivers = new Dictionary&lt;string, DriverProfile&gt;();
            await Task.WhenAll(bids.Select(async bid =&gt;
            {
                if (!bidDrivers.ContainsKey(bid.Id))
                {
                    var driver = await _driverProfileService.GetAsync(bid.DriverEmail);
                    bidDrivers.Add(bid.Id, driver);
                }
            }));
            return bidDrivers;
        }

        private async Task&lt;Dictionary&lt;string, UserCore&gt;&gt; GetBidIdToUserMap(
            IEnumerable&lt;Bid&gt; bids,
            Dictionary&lt;string, UserCore&gt;? cache
        )
        {
            if (cache != null)
                return cache;
            var bidUsers = new Dictionary&lt;string, UserCore&gt;();
            await Task.WhenAll(bids.Select(async bid =&gt;
            {
                if (!bidUsers.ContainsKey(bid.Id))
                {
                    var user = await _userCoreService.GetAsync(bid.DriverEmail);
                    bidUsers.Add(bid.Id, user);
                }
            }));
            return bidUsers;
        }

        private async Task&lt;List&lt;SearchedTrip&gt;&gt; TripsToSearchedTrips(List&lt;Trip&gt; trips)
        {
            var tripRoutes = await GetTripIdToRouteMap(trips, null);
            var tripBids = await GetTripIdToBidMap(trips, null);
            var tripMinBids = await GetTripIdToMinBidAmountMap(trips, null, tripBids);
            var bidDrivers = await GetBidIdToDriverMap(tripBids.Values.SelectMany(x =&gt; x), null);
            var bidUsers = await GetBidIdToUserMap(tripBids.Values.SelectMany(x =&gt; x), null);

            var searchedTrips = trips.Select(trip =&gt; new SearchedTrip
            {
                TripId = trip.Id,
                TripName = trip.Name,
                Thumbnail = tripRoutes[trip.Id].Image,
                GeoJson = tripRoutes[trip.Id].GeoJson,
                StartTime = trip.StartTime,
                Distance = tripRoutes[trip.Id].Distance,
                Duration = tripRoutes[trip.Id].Duration,
                PickupAddress = trip.PickupAddress,
                DestinationAddress = trip.DestinationAddress,
                CurrentMinBidCentsAmount = tripMinBids[trip.Id],
                TripBids = tripBids[trip.Id].Select(bid =&gt; new SearchedBid
                {
                    DriverName = bidUsers[bid.Id].Name,
                    DriverRating = bidDrivers[bid.Id].Rating,
                    DriverNumRatings = bidDrivers[bid.Id].NumRatings,
                    CentsAmount = bid.CentsAmount
                }).ToList(),
            }).ToList();

            return searchedTrips;
        }

        /// &lt;summary&gt;
        /// Get all biddable trips.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// &lt;see cref=&quot;OkObjectResult&quot;/&gt; if the biddable trips are successfully returned
        /// &lt;/returns&gt;
        [HttpGet]
        [Route(&quot;allTrips&quot;)]
        [ProducesResponseType(typeof(List&lt;SearchedTrip&gt;), StatusCodes.Status200OK)]
        [SwaggerOperation(Summary = &quot;Get all biddable trips.&quot;)]
        [SwaggerResponse(StatusCodes.Status200OK, &quot;Successfully returned all biddable trips.&quot;)]
        public async Task&lt;IActionResult&gt; GetAllAvailableTrips()
        {
            var availableTrips = await GetEligibleMarketTrips();
            var searchedTrips = await TripsToSearchedTrips(availableTrips);
            return Ok(searchedTrips);
        }

        private double EuclideanDistance(double lat1, double long1, double lat2, double long2)
        {
            double dLat = lat2 - lat1;
            double dLong = long2 - long1;
            return Math.Sqrt(dLat * dLat + dLong * dLong);
        }

        private double TripEuclideanDistance(Trip trip)
        {
            return EuclideanDistance(
                trip.PickupLat,
                trip.PickupLong,
                trip.DestinationLat,
                trip.DestinationLong
            );
        }

        private double TripCurrentToStartDistance(Trip trip, TripMarketOptions options)
        {
            return EuclideanDistance(
                (double)options.CurrentLat,
                (double)options.CurrentLong,
                trip.PickupLat,
                trip.PickupLong
            );
        }

        private double TripEndToTargetDistance(Trip trip, TripMarketOptions options)
        {
            return EuclideanDistance(
                trip.DestinationLat,
                trip.DestinationLong,
                (double)options.TargetLat,
                (double)options.TargetLong
            );
        }

        private bool TripPassesMaxCurrentToStartDistance(Trip trip, TripMarketOptions options)
        {
            return TripCurrentToStartDistance(trip, options) &lt;= options.MaxCurrentToStartDistance;
        }

        private bool TripPassesMaxEndToTargetDistance(Trip trip, TripMarketOptions options)
        {
            return TripEndToTargetDistance(trip, options) &lt;= options.MaxEndToTargetDistance;
        }

        private async Task&lt;List&lt;Trip&gt;&gt; GetEligibleMarketTrips()
        {
            var allTrips = await _tripService.GetAllTripsAsync();
            return allTrips.Where(trip =&gt; String.IsNullOrEmpty(trip.DriverEmail) &amp;&amp; trip.StartTime.ToLocalTime() &gt; DateTime.Now).ToList();
        }

        private async Task&lt;List&lt;Trip&gt;&gt; GetFilteredAndSortedTrips(TripMarketOptions options)
        {
            var allTrips = await GetEligibleMarketTrips();
            Dictionary&lt;string, GeographicRoute&gt;? tripRoutes = null;
            Dictionary&lt;string, uint?&gt;? tripMinBidAmounts = null;

            IEnumerable&lt;Trip&gt; someTrips = allTrips;

            if (options.MaxCurrentToStartDistance != null)
            {
                if (options.CurrentLat == null || options.CurrentLong == null)
                    throw new ArgumentException(&quot;Must include current coordinates&quot;);
                someTrips = someTrips.Where(trip =&gt; TripPassesMaxCurrentToStartDistance(trip, options));
            }

            if (options.MaxEndToTargetDistance != null)
            {
                if (options.TargetLat == null || options.TargetLong == null)
                    throw new ArgumentException(&quot;Must include target coordinates&quot;);
                someTrips = someTrips.Where(trip =&gt; TripPassesMaxEndToTargetDistance(trip, options));
            }

            if (options.MaxEuclideanDistance != null)
            {
                someTrips = someTrips.Where(trip =&gt; TripEuclideanDistance(trip) &lt;= options.MaxEuclideanDistance);
            }

            if (options.MaxRouteDistance != null)
            {
                tripRoutes = await GetTripIdToRouteMap(allTrips, tripRoutes);
                someTrips = someTrips.Where(trip =&gt; tripRoutes[trip.Id].Distance &lt;= options.MaxRouteDistance);
            }

            if (options.MinCurrentMinBid != null)
            {
                tripMinBidAmounts = await GetTripIdToMinBidAmountMap(allTrips, tripMinBidAmounts, null);
                someTrips = someTrips.Where(trip =&gt; tripMinBidAmounts[trip.Id] &gt;= options.MinCurrentMinBid);
            }

            var filteredTrips = someTrips.ToList();

            IOrderedEnumerable&lt;Trip&gt; sortedTrips = null!;
            foreach (var sortMethod in options.SortMethods)
            {
                switch (sortMethod)
                {
                    case &quot;euclideanDistance&quot;:
                        if (sortedTrips == null)
                            sortedTrips = filteredTrips.OrderBy(TripEuclideanDistance);
                        else
                            sortedTrips = sortedTrips.ThenBy(TripEuclideanDistance);
                        break;
                    case &quot;routeDistance&quot;:
                        tripRoutes = await GetTripIdToRouteMap(filteredTrips, tripRoutes);
                        if (sortedTrips == null)
                            sortedTrips = filteredTrips.OrderBy(trip =&gt; tripRoutes[trip.Id].Distance);
                        else
                            sortedTrips = sortedTrips.ThenBy(trip =&gt; tripRoutes[trip.Id].Distance);
                        break;
                    case &quot;routeDuration&quot;:
                        tripRoutes = await GetTripIdToRouteMap(filteredTrips, tripRoutes);
                        if (sortedTrips == null)
                            sortedTrips = filteredTrips.OrderBy(trip =&gt; tripRoutes[trip.Id].Duration);
                        else
                            sortedTrips = sortedTrips.ThenBy(trip =&gt; tripRoutes[trip.Id].Duration);
                        break;
                    case &quot;currentToStartDistance&quot;:
                        if (options.CurrentLat == null || options.CurrentLong == null)
                            throw new ArgumentException(&quot;Must include current coordinates&quot;);
                        if (sortedTrips == null)
                            sortedTrips = filteredTrips.OrderBy(trip =&gt; TripCurrentToStartDistance(trip, options));
                        else
                            sortedTrips = sortedTrips.ThenBy(trip =&gt; TripCurrentToStartDistance(trip, options));
                        break;
                    case &quot;endToTargetDistance&quot;:
                        if (options.TargetLat == null || options.TargetLong == null)
                            throw new ArgumentException(&quot;Must include target coordinates&quot;);
                        if (sortedTrips == null)
                            sortedTrips = filteredTrips.OrderBy(trip =&gt; TripEndToTargetDistance(trip, options));
                        else
                            sortedTrips = sortedTrips.ThenBy(trip =&gt; TripEndToTargetDistance(trip, options));
                        break;
                    case &quot;currentMinBid&quot;:
                        tripMinBidAmounts = await GetTripIdToMinBidAmountMap(filteredTrips, tripMinBidAmounts, null);
                        if (sortedTrips == null)
                            sortedTrips = filteredTrips.OrderBy(trip =&gt; tripMinBidAmounts[trip.Id]);
                        else
                            sortedTrips = sortedTrips.ThenBy(trip =&gt; tripMinBidAmounts[trip.Id]);
                        break;
                    case &quot;startTime&quot;:
                        if (sortedTrips == null)
                            sortedTrips = filteredTrips.OrderBy(trip =&gt; trip.StartTime);
                        else
                            sortedTrips = sortedTrips.ThenBy(trip =&gt; trip.StartTime);
                        break;
                    default:
                        throw new ArgumentException(&quot;Invalid sort method&quot;);
                }
            }

            List&lt;Trip&gt; finalTrips;
            if (sortedTrips != null)
                finalTrips = sortedTrips.ToList();
            else
                finalTrips = filteredTrips;

            return finalTrips;
        }

        /// &lt;summary&gt;
        /// Get biddable trips and filter and sort using options.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;options&quot;&gt;The filtering and searching options form.&lt;/param&gt;
        /// &lt;returns&gt;
        /// &lt;see cref=&quot;OkObjectResult&quot;/&gt; if the biddable trips are successfully returned,
        /// &lt;see cref=&quot;BadRequestObjectResult&quot;/&gt; if the options are invalid
        /// &lt;/returns&gt;
        [HttpGet]
        [HttpPost]
        [Route(&quot;tripMarket&quot;)]
        [ProducesResponseType(typeof(List&lt;SearchedTrip&gt;), StatusCodes.Status200OK)]
        [SwaggerOperation(Summary = &quot;Get biddable trips and filter and sort using options.&quot;)]
        [SwaggerResponse(StatusCodes.Status200OK, &quot;Successfully returned the biddable trips.&quot;)]
        [SwaggerResponse(StatusCodes.Status400BadRequest, &quot;Invalid options&quot;)]
        public async Task&lt;IActionResult&gt; GetAllAvailableTrips([FromBody] TripMarketOptions options)
        {
            List&lt;Trip&gt; trips;
            try
            {
                trips = await GetFilteredAndSortedTrips(options);
            }
            catch (ArgumentException ex)
            {
                return BadRequest(new { Error = ex.Message });
            }
            var searchedTrips = await TripsToSearchedTrips(trips);
            return Ok(searchedTrips);
        }

        /// &lt;summary&gt;
        /// Rate a rider.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;giveRating&quot;&gt;The rating form.&lt;/param&gt;
        /// &lt;returns&gt;
        /// &lt;see cref=&quot;OkResult&quot;/&gt; if the rider was successfully rated,
        /// &lt;see cref=&quot;BadRequestObjectResult&quot;/&gt; if the user is invalid or not authenticated,
        /// &lt;see cref=&quot;UnauthorizedResult&quot;/&gt; if the user is not a driver
        /// &lt;/returns&gt;
        [Authorize]
        [HttpPost]
        [Route(&quot;rating&quot;)]
        [SwaggerOperation(Summary = &quot;Rate a rider.&quot;)]
        [SwaggerResponse(StatusCodes.Status200OK, &quot;Successfully rated the rider.&quot;)]
        [SwaggerResponse(StatusCodes.Status400BadRequest, &quot;Invalid user/auth or trip.&quot;)]
        [SwaggerResponse(StatusCodes.Status401Unauthorized, &quot;The user is not a driver.&quot;)]
        public async Task&lt;IActionResult&gt; RateRider([FromBody] GiveRating giveRating)
        {
            ClaimsPrincipal currentUser = this.User;

            if (currentUser == null) { return BadRequest(new { Error = &quot;Invalid User/Auth&quot; }); };

            var role = currentUser.FindFirstValue(ClaimTypes.Role);

            if (role != &quot;driver&quot;) { return Unauthorized(); }

            var trip = await _tripService.GetTripByIdAsync(giveRating.TripId);
            if (trip == null) { return BadRequest(new { Error = &quot;Trip does not exist&quot; }); }

            var driverEmail = currentUser.FindFirstValue(ClaimTypes.Name);
            if (driverEmail != trip.DriverEmail) { return Unauthorized(); }

            var riderEmail = trip.RiderEmail;
            if (string.IsNullOrEmpty(riderEmail)) { return BadRequest(new { Error = &quot;Trip does not have a rider (somehow)&quot; }); }

            if (trip.StartTime.ToLocalTime() &gt;= DateTime.Now) { return BadRequest(new { Error = &quot;Trip has not been taken yet&quot; }); }

            if (trip.RiderHasBeenRated) { return BadRequest(new { Error = &quot;Rider has already been rated for this trip&quot; }); }

            var rider = await _riderProfileService.GetAsync(riderEmail);
            if (rider == null) { return BadRequest(new { Error = &quot;Rider does not exist&quot; }); }

            if (rider.Rating == null)
                rider.Rating = 0;
            if (rider.NumRatings == null)
                rider.NumRatings = 0;

            var totalRatings = rider.Rating * (double)rider.NumRatings;

            rider.NumRatings++;

            rider.Rating = (totalRatings + (double)giveRating.RatingGiven) / (double)rider.NumRatings;

            await _riderProfileService.UpdateAsync(rider.Email, rider);

            trip.RiderHasBeenRated = true;

            await _tripService.UpdateAsync(giveRating.TripId, trip);
            return Ok();
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[28,9,36,10,1],[37,9,37,10,1],[38,13,38,58,1],[39,13,39,56,1],[40,13,40,48,1],[41,13,41,40,1],[42,13,42,38,1],[43,13,43,62,1],[44,13,44,66,1],[45,9,45,10,1],[64,9,64,10,1],[65,13,65,53,1],[66,13,66,37,1],[67,13,67,14,0],[68,17,68,72,0],[70,13,70,68,1],[71,13,71,34,1],[72,13,72,14,0],[73,17,73,39,0],[76,13,76,69,1],[77,13,77,72,1],[78,13,78,69,1],[79,13,79,88,1],[80,13,80,94,1],[81,13,81,85,1],[82,13,82,77,1],[83,13,83,20,1],[83,22,83,29,1],[83,30,83,32,1],[83,33,83,67,1],[84,13,84,14,1],[88,17,88,77,1],[89,17,89,55,1],[90,17,90,78,1],[92,17,92,176,1],[93,17,93,45,1],[94,17,94,74,1],[95,17,95,92,1],[96,17,96,18,1],[97,21,97,75,1],[98,21,98,46,1],[99,21,99,50,1],[100,21,100,56,1],[101,21,101,63,1],[102,21,102,63,1],[103,21,103,65,1],[104,21,104,65,1],[105,21,105,41,1],[106,21,106,95,1],[107,21,107,91,1],[108,21,108,56,1],[109,21,109,63,1],[110,21,110,56,1],[111,21,111,64,1],[112,21,112,74,1],[113,21,113,48,1],[114,17,114,18,1],[115,22,115,65,1],[116,17,116,18,1],[118,21,118,83,1],[119,21,119,95,1],[120,21,120,91,1],[121,21,121,52,1],[122,21,122,56,1],[123,21,123,69,1],[124,21,124,69,1],[125,21,125,62,1],[126,21,126,71,1],[127,21,127,71,1],[128,21,128,47,1],[129,21,129,62,1],[130,21,130,62,1],[131,21,131,69,1],[132,21,132,156,1],[133,21,133,64,1],[134,21,134,64,1],[135,21,135,70,1],[136,21,136,80,1],[137,21,137,55,1],[138,17,138,18,1],[140,17,140,18,1],[142,21,142,89,1],[143,21,143,91,1],[144,21,144,95,1],[145,21,145,54,1],[146,21,146,58,1],[147,21,147,71,1],[148,21,148,71,1],[149,21,149,64,1],[150,21,150,73,1],[151,21,151,73,1],[152,21,152,64,1],[153,21,153,64,1],[154,21,154,71,1],[155,21,155,86,1],[156,21,156,68,1],[157,21,157,28,1],[157,30,157,41,0],[157,42,157,44,1],[157,45,157,80,1],[158,21,158,22,0],[159,25,159,69,0],[160,25,160,100,0],[161,25,161,106,0],[162,25,162,56,0],[163,25,163,66,0],[164,25,164,66,0],[165,25,165,73,0],[166,25,166,64,0],[167,25,167,58,0],[168,25,168,26,0],[169,29,169,56,0],[170,29,170,73,0],[171,25,171,26,0],[173,25,173,26,0],[174,29,174,57,0],[175,29,175,67,0],[176,25,176,26,0],[177,21,177,22,0],[178,21,178,72,1],[179,21,179,82,1],[180,21,180,59,1],[181,17,181,18,1],[182,13,182,14,1],[183,13,183,61,1],[184,13,184,63,1],[185,13,185,59,1],[186,13,186,40,1],[187,9,187,10,1],[206,9,206,10,0],[207,13,207,53,0],[208,13,208,37,0],[209,13,209,14,0],[210,17,210,72,0],[212,13,212,68,0],[213,13,213,34,0],[214,13,214,14,0],[215,17,215,39,0],[217,13,217,69,0],[218,13,218,72,0],[219,13,219,87,0],[220,13,220,69,0],[221,13,221,50,0],[222,13,222,43,0],[223,13,223,52,0],[224,13,224,75,0],[225,13,225,40,0],[226,9,226,10,0],[245,9,245,10,1],[246,13,246,53,1],[248,13,248,37,1],[249,13,249,14,0],[250,17,250,72,0],[252,13,252,68,1],[253,13,253,34,1],[254,13,254,14,0],[255,17,255,39,0],[257,13,257,85,1],[258,13,258,88,1],[259,13,259,14,0],[260,17,260,80,0],[264,13,264,69,1],[266,13,266,72,1],[267,13,267,87,1],[268,13,268,34,1],[269,13,269,14,1],[271,17,271,129,1],[272,17,272,18,0],[273,21,273,86,0],[276,13,276,14,1],[278,13,278,34,1],[279,13,279,14,1],[280,17,280,113,1],[281,17,281,49,1],[282,17,282,41,1],[283,13,283,14,1],[284,13,284,58,1],[285,13,285,14,0],[286,17,286,51,0],[287,13,287,14,0],[288,13,288,59,1],[289,13,289,14,0],[290,17,290,53,0],[291,13,291,14,0],[292,13,292,68,1],[293,13,293,14,0],[294,17,294,76,0],[295,13,295,14,0],[296,13,296,65,1],[297,13,297,75,1],[298,13,298,25,1],[299,9,299,10,1],[319,9,319,10,1],[320,13,320,53,1],[321,13,321,72,1],[322,13,322,68,1],[323,13,323,34,1],[324,13,324,14,1],[325,17,325,39,1],[328,13,328,77,1],[329,13,329,70,1],[330,13,330,14,1],[331,17,331,69,1],[334,13,334,104,1],[335,13,335,14,1],[336,17,336,98,1],[339,13,339,42,1],[340,13,340,14,1],[341,17,341,83,1],[344,13,344,102,1],[344,102,344,130,1],[344,130,344,132,1],[345,13,345,37,1],[346,13,346,14,1],[348,17,348,63,1],[349,17,349,76,1],[350,13,350,14,1],[352,13,352,14,1],[354,17,359,20,1],[360,13,360,14,1],[362,13,362,83,1],[363,13,363,77,1],[364,13,364,90,1],[365,13,380,15,1],[382,13,382,25,1],[383,9,383,10,1],[402,9,402,10,1],[403,13,403,53,1],[404,13,404,72,1],[405,13,405,68,1],[406,13,406,34,1],[407,13,407,14,0],[408,17,408,39,0],[411,13,411,69,1],[412,13,412,62,1],[413,13,413,14,0],[414,17,414,69,0],[417,13,417,104,1],[418,13,418,14,1],[419,17,419,98,1],[422,13,422,102,1],[422,102,422,122,1],[422,122,422,124,1],[423,13,423,37,1],[424,13,424,14,1],[425,17,425,63,1],[426,13,426,14,1],[428,13,428,14,1],[429,17,429,81,1],[432,13,432,25,1],[433,9,433,10,1],[439,9,439,10,1],[440,13,440,31,1],[441,17,441,30,0],[442,13,442,72,1],[443,13,444,13,1],[444,13,444,14,1],[444,14,445,17,1],[445,17,450,19,1],[450,19,451,17,1],[451,17,451,48,1],[451,48,452,13,1],[452,13,452,14,1],[452,14,452,17,1],[453,13,453,31,1],[454,9,454,10,1],[460,9,460,10,1],[461,13,461,31,1],[462,17,462,30,1],[463,13,463,64,1],[464,13,465,13,1],[465,13,465,14,1],[465,14,466,17,1],[466,17,466,72,1],[466,72,467,17,1],[467,17,467,45,1],[467,45,468,13,1],[468,13,468,14,1],[468,14,468,17,1],[469,13,469,29,1],[470,9,470,10,1],[477,9,477,10,1],[478,13,478,31,1],[479,17,479,30,1],[480,13,480,65,1],[481,13,481,69,1],[482,13,482,20,1],[482,22,482,30,1],[482,31,482,33,1],[482,34,482,39,1],[483,13,483,14,1],[484,17,486,53,1],[486,53,486,68,1],[486,68,487,19,1],[488,13,488,14,1],[489,13,489,38,1],[490,9,490,10,1],[496,9,496,10,1],[497,13,497,31,1],[498,17,498,30,0],[499,13,499,70,1],[500,13,501,13,1],[501,13,501,14,1],[501,14,502,17,1],[502,17,502,53,1],[502,53,503,17,1],[503,17,503,18,1],[503,18,504,21,1],[504,21,504,88,1],[504,88,505,21,1],[505,21,505,52,1],[505,52,506,17,1],[506,17,506,18,1],[506,18,507,13,1],[507,13,507,14,1],[507,14,507,17,1],[508,13,508,31,1],[509,9,509,10,1],[515,9,515,10,1],[516,13,516,31,1],[517,17,517,30,0],[518,13,518,63,1],[519,13,520,13,1],[520,13,520,14,1],[520,14,521,17,1],[521,17,521,51,1],[521,51,522,17,1],[522,17,522,18,1],[522,18,523,21,1],[523,21,523,81,1],[523,81,524,21,1],[524,21,524,48,1],[524,48,525,17,1],[525,17,525,18,1],[525,18,526,13,1],[526,13,526,14,1],[526,14,526,17,1],[527,13,527,29,1],[528,9,528,10,1],[531,9,531,10,1],[532,13,532,69,1],[533,13,533,65,1],[534,13,534,87,1],[535,13,535,88,1],[535,88,535,89,1],[535,89,535,98,1],[536,13,536,84,1],[536,84,536,85,1],[536,85,536,94,1],[538,13,538,54,1],[538,54,550,60,1],[550,60,556,18,1],[556,18,557,14,1],[557,14,557,25,1],[559,13,559,34,1],[560,9,560,10,1],[574,9,574,10,1],[575,13,575,65,1],[576,13,576,76,1],[577,13,577,38,1],[578,9,578,10,1],[581,9,581,10,1],[582,13,582,39,1],[583,13,583,42,1],[584,13,584,59,1],[585,9,585,10,1],[588,9,588,10,1],[589,13,594,15,1],[595,9,595,10,1],[598,9,598,10,1],[599,13,604,15,1],[605,9,605,10,1],[608,9,608,10,1],[609,13,614,15,1],[615,9,615,10,1],[618,9,618,10,1],[619,13,619,99,1],[620,9,620,10,1],[623,9,623,10,1],[624,13,624,93,1],[625,9,625,10,1],[628,9,628,10,1],[629,13,629,66,1],[630,13,630,43,1],[630,43,630,128,1],[630,128,630,139,1],[631,9,631,10,1],[634,9,634,10,1],[635,13,635,59,1],[636,13,636,68,1],[637,13,637,65,1],[639,13,639,52,1],[641,13,641,59,1],[642,13,642,14,1],[643,17,643,79,1],[644,21,644,85,0],[645,17,645,53,1],[645,53,645,103,1],[645,103,645,105,1],[646,13,646,14,1],[648,13,648,56,1],[649,13,649,14,1],[650,17,650,77,1],[651,21,651,84,0],[652,17,652,53,1],[652,53,652,100,1],[652,100,652,102,1],[653,13,653,14,1],[655,13,655,54,1],[656,13,656,14,1],[657,17,657,53,1],[657,53,657,112,1],[657,112,657,114,1],[658,13,658,14,1],[660,13,660,50,1],[661,13,661,14,0],[662,17,662,78,0],[663,17,663,53,0],[663,53,663,109,0],[663,109,663,111,0],[664,13,664,14,0],[666,13,666,50,1],[667,13,667,14,1],[668,17,668,105,1],[669,17,669,53,1],[669,53,669,107,1],[669,107,669,109,1],[670,13,670,14,1],[672,13,672,52,1],[674,13,674,58,1],[675,13,675,20,1],[675,22,675,36,1],[675,37,675,39,1],[675,40,675,59,1],[676,13,676,14,1],[677,17,677,36,1],[680,25,680,49,0],[681,29,681,88,0],[683,29,683,85,0],[684,25,684,31,0],[686,25,686,91,1],[687,25,687,49,1],[688,29,688,73,1],[688,73,688,101,1],[688,101,688,103,1],[690,29,690,70,0],[690,70,690,98,0],[690,98,690,100,0],[691,25,691,31,1],[693,25,693,91,0],[694,25,694,49,0],[695,29,695,73,0],[695,73,695,101,0],[695,101,695,103,0],[697,29,697,70,0],[697,70,697,98,0],[697,98,697,100,0],[698,25,698,31,0],[700,25,700,87,1],[701,29,701,93,0],[702,25,702,49,1],[703,29,703,73,1],[703,73,703,114,1],[703,114,703,116,1],[705,29,705,70,0],[705,70,705,111,0],[705,111,705,113,0],[706,25,706,31,1],[708,25,708,85,1],[709,29,709,92,0],[710,25,710,49,1],[711,29,711,73,0],[711,73,711,111,0],[711,111,711,113,0],[713,29,713,70,1],[713,70,713,108,0],[713,108,713,110,1],[714,25,714,31,1],[716,25,716,118,1],[717,25,717,49,1],[718,29,718,73,1],[718,73,718,99,1],[718,99,718,101,1],[720,29,720,70,0],[720,70,720,96,0],[720,96,720,98,0],[721,25,721,31,1],[723,25,723,49,0],[724,29,724,73,0],[724,73,724,87,0],[724,87,724,89,0],[726,29,726,70,0],[726,70,726,84,0],[726,84,726,86,0],[727,25,727,31,0],[729,25,729,76,0],[731,13,731,14,1],[734,13,734,37,1],[735,17,735,51,1],[737,17,737,44,1],[739,13,739,31,1],[740,9,740,10,1],[758,9,758,10,1],[761,13,761,14,1],[762,17,762,66,1],[763,13,763,14,1],[764,13,764,41,0],[765,13,765,14,0],[766,17,766,63,0],[768,13,768,67,1],[769,13,769,38,1],[770,9,770,10,1],[789,9,789,10,1],[790,13,790,53,1],[792,13,792,37,1],[792,38,792,39,0],[792,40,792,95,0],[792,97,792,98,1],[794,13,794,68,1],[796,13,796,34,1],[796,35,796,36,0],[796,37,796,59,0],[798,13,798,79,1],[799,13,799,30,1],[799,31,799,32,1],[799,33,799,90,1],[801,13,801,75,1],[802,13,802,49,1],[802,50,802,51,1],[802,52,802,74,1],[804,13,804,46,1],[805,13,805,50,1],[805,51,805,52,0],[805,53,805,127,0],[807,13,807,62,1],[807,63,807,64,0],[807,65,807,130,0],[809,13,809,40,1],[809,41,809,42,0],[809,43,809,123,0],[811,13,811,73,1],[812,13,812,31,1],[812,32,812,33,0],[812,34,812,92,0],[814,13,814,38,1],[815,17,815,34,0],[816,13,816,42,1],[817,17,817,38,0],[819,13,819,72,1],[821,13,821,32,1],[823,13,823,103,1],[825,13,825,72,1],[827,13,827,43,1],[829,13,829,69,1],[830,13,830,25,1],[831,9,831,10,1]]);
    </script>
  </body>
</html>